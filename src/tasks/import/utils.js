const csvReader = require('fast-csv')
const xmlConverter = require('xml-js')
const chalk = require('chalk')
const path = require('path')

/**
 * @method discoverExtension
 * @param  {String} fileName - Name of the file
 * @return {String}
 */

const discoverExtension = (fileName) => {
  const extension = path.extname(fileName)

  if (extension !== '') {
    return extension.replace('.', '')
  }
}

/**
 * @method sendContent
 * @param  {Object} api - A api object
 * @param  {Object} contents - Object with the content to be sent
 * @return {Promise}
 */

const sendContent = async (api, contents) => {
  for (const key in contents) {
    await api.getClient()
      .post(`spaces/${api.spaceId}/stories`, { story: contents[key] })
      .then(res => {
        console.log(`${chalk.green('âœ“')} ${res.data.story.name} was created `)
        return res.data.story.name
      })
      .catch(err => Promise.reject(err))
  }
}

// This function is used to sanitize the json generated by the xml2js() function,
// because with each text generated in the conversion it is encapsulated within
// an object { "_text": 'text'}

const removeJsonTextAttribute = (value, parentElement) => {
  const keyNo = Object.keys(parentElement._parent).length
  const keyName = Object.keys(parentElement._parent)[keyNo - 1]
  parentElement._parent[keyName] = !isNaN(value) ? Number(value) : value
}

/**
 * @method csvParser
 * @param  {String} stream - Stream with a CSV content
 * @param  {String} typeOfContent - Content type
 * @param  {Number} folderID - Storyblok folder id, default value is 0
 * @param  {String} delimiter - Csv file delimiter, default value is ';'
 * @return {Array}
 */

const csvParser = (stream, typeOfContent, folderID = 0, delimiter = ';') => new Promise(resolve => {
  console.log()
  console.log(`${chalk.blue('-')} Reading CSV file... `)
  console.log()

  const story = []

  csvReader.parseStream(stream, { headers: true, delimiter: delimiter })
    .on('error', error => console.error(error))
    .on('data', line => {
      const content = Object.keys(line).reduce((acc, key) => {
        acc[key] = line[key]
        return acc
      }, {})

      story.push({
        slug: line.path,
        name: line.title,
        parent_id: folderID,
        content: {
          component: typeOfContent,
          ...content
        }
      })
    })
    .on('end', () => {
      resolve(story)
    })
})

/**
 * @method xmlParser
 * @param  {Object} data - XML content
 * @param  {String} typeOfContent - Content type
 * @param  {Number} folderID - Storyblok folder id, default value is 0
 * @return {Promise}
 */

const xmlParser = async (data, typeOfContent, folderID = 0) => {
  console.log()
  console.log(`${chalk.blue('-')} Reading XML file... `)
  console.log()

  const options = {
    compact: true,
    trim: true,
    ignoreDoctype: true,
    textFn: removeJsonTextAttribute
  }
  const contentParsed = xmlConverter.xml2js(data, options)
  const story = []

  contentParsed.root.row.map(line => {
    const content = Object.keys(line).reduce((acc, key) => {
      acc[key] = line[key]
      return acc
    }, {})

    story.push({
      slug: line.path,
      name: line.title,
      parent_id: folderID,
      content: {
        component: typeOfContent,
        ...content
      }
    })
  })

  return Promise.resolve(story)
}

/**
 * @method jsonParser
 * @param  {Object} data - Json with content
 * @param  {String} typeOfContent - Content type
 * @param  {Number} folderID - Storyblok folder id, default value is 0
 * @return {Array}
 */

const jsonParser = async (data, typeOfContent, folderID = 0) => {
  console.log()
  console.log(`${chalk.blue('-')} Reading JSON file... `)
  console.log()

  const copyData = JSON.parse(data)
  const story = []

  for (const key in copyData) {
    story.push({
      slug: key,
      name: copyData[key].title || key,
      parent_id: folderID,
      content: {
        component: typeOfContent,
        ...copyData[key]
      }
    })
  }
  return Promise.resolve(story)
}

module.exports = {
  csvParser,
  xmlParser,
  jsonParser,
  sendContent,
  discoverExtension
}
